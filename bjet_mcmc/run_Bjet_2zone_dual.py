"""
Two-model runner that **does not interpolate** when summing _ss, _cs, _cs2:
- Assumes _ss, _cs, and _cs2 share the same X grid (as generated by Bjet).
- Handles different lengths by aligning from the start; _ss may truncate earlier at high Î½.
- Uses the longest component grid as the model's total grid and sums arrays by index.
- For Model1 + Model2, if the two models share the same grid, sums by index; otherwise,
  falls back to a single, light interpolation step **only** for cross-model summation.

Outputs:
- Plots data + Model 1 + Model 2 + (Model 1 + 2).
- Stores each model run in DATA_FOLDER/<subdir>.
"""
import os, glob, shutil
import numpy as np
import matplotlib.pyplot as plt

import blazar_model
import blazar_utils
from blazar_properties import *

h = 4.135667662E-15
def v_to_e(val): return val * h
def e_to_v(val): return val / h

# ---- User inputs ----
Source = "Mrk421"
parameter_file_1 = "parameter_files/Mrk421_ext_mz.par"
parameter_file_2 = "parameter_files/Mrk421_com_multizone_scaleup.par"
name_stem = "test_bj"
subdir_1 = "model_A_nointerp"
subdir_2 = "model_B_nointerp"

# ---- Plot/data config ----
if Source == "Mrk421":
    Ylim = [1e-15,1e-8]
    Xlim = [1e8,1e28]
    instrument_data_file = "real_data/MAGIC_Mrk421_SED_MJD60291_vts.dat"
else:
    raise ValueError("Only Mrk421 wired for this minimal example.")

def ensure_dir(d): os.makedirs(d, exist_ok=True)

def move_outputs(src_folder, dst_folder, stem=name_stem):
    ensure_dir(dst_folder)
    pats = [f"{stem}_ss.dat", f"{stem}_cs.dat", f"{stem}_cs2.dat", f"{stem}_nuc.dat"]
    for pat in pats:
        for src in glob.glob(os.path.join(src_folder, pat)):
            shutil.move(src, os.path.join(dst_folder, os.path.basename(src)))

def _load_log_component(path):
    """Load a (log10 v, log10 vFv) file and return linear arrays (v, f)."""
    if not os.path.exists(path):
        return None
    arr = np.loadtxt(path)
    logv, logf = arr[:,0], arr[:,2]
    v = 10.0**logv
    f = 10.0**logf
    m = np.isfinite(v) & np.isfinite(f) & (v > 0) & (f >= 0)
    if m.sum() < 2:
        return None
    return v[m], f[m]

def _align_and_sum(reference_v, parts):
    """
    Sum parts (each as (v, f)) onto the reference_v grid **without interpolation**,
    assuming identical grid values at matching indices and parts may be shorter.
    """
    total = np.zeros_like(reference_v)
    for (v, f) in parts:
        if v is None: 
            continue
        n = len(v)
        # Check that the first n points match the reference within tight tolerance
        if n > len(reference_v):
            raise ValueError("Component grid longer than reference grid unexpectedly.")
        if not np.allclose(v, reference_v[:n], rtol=0, atol=1e-10 * np.maximum(1.0, reference_v[:n])):
            raise RuntimeError("Component grid does not align with reference grid; interpolation would be required.")
        total[:n] += f
    return total

def load_total_nointerp(data_folder, stem=name_stem):
    """
    Build model total using the union (by index) of _ss, _cs, _cs2 grids:
    - Determine the longest grid among available components and use it as reference_v.
    - Sum other components into the overlapping prefix by index (no interpolation).
    """
    p_ss  = os.path.join(BASE_PATH,  data_folder, f"{stem}_ss.dat")
    p_cs  = os.path.join(BASE_PATH,  data_folder, f"{stem}_cs.dat")
    p_cs2 = os.path.join(FOLDER_PATH,data_folder, f"{stem}_cs2.dat")

    vc = _load_log_component(p_cs)
    vs = _load_log_component(p_ss)
    v2 = _load_log_component(p_cs2)

    # Require at least ss and cs; but if ss is missing and cs present, still proceed
    parts = [x for x in [vs, vc, v2] if x is not None]
    if vc is None and vs is None:
        raise RuntimeError("Need at least _cs or _ss to build a model total.")

    # choose reference as the longest available
    lens = [len(v) for (v, f) in parts]
    ref_idx = int(np.argmax(lens))
    reference_v = parts[ref_idx][0]

    # Sum all available parts by index (prefix match)
    total = _align_and_sum(reference_v, parts)
    return reference_v, total, {"ss": vs, "cs": vc, "cs2": v2}

def _sum_models(vA, fA, vB, fB):
    """
    Sum two model totals. If grids match, sum by index.
    Otherwise, fall back to minimal interpolation for cross-model sum only.
    """
    if len(vA) == len(vB) and np.allclose(vA, vB, rtol=0, atol=1e-10 * np.maximum(1.0, vA)):
        return vA, fA + fB
    # different grids -> light interpolation on union grid
    logv_union = np.unique(np.concatenate([np.log10(vA), np.log10(vB)]))
    v_union = 10.0**logv_union
    fA_u = np.interp(logv_union, np.log10(vA), fA, left=0.0, right=0.0)
    fB_u = np.interp(logv_union, np.log10(vB), fB, left=0.0, right=0.0)
    return v_union, fA_u + fB_u

if __name__ == "__main__":
    # data
    v_data, vFv_data, err_data, instrument_data, nubin_data = blazar_utils.read_data(instrument_data_file, instrument=True)
    uplims = [False]*len(v_data); lolims=[False]*len(v_data)
    for i in range(len(err_data[1])):
        if err_data[1][i] == -1:
            uplims[i] = True; err_data[0][i] = vFv_data[i]/4
        if err_data[0][i] == -1:
            lolims[i] = True; err_data[1][i] = vFv_data[i]/4

    # run model 1
    blazar_model.file_make_SED(parameter_file=parameter_file_1, data_folder=None, executable=None, prev_files=False, verbose=True)
    src = os.path.join(BASE_PATH, DATA_FOLDER)
    dstA = os.path.join(BASE_PATH, DATA_FOLDER, subdir_1)
    move_outputs(src, dstA, stem=name_stem)

    # run model 2
    blazar_model.file_make_SED(parameter_file=parameter_file_2, data_folder=None, executable=None, prev_files=False, verbose=True)
    dstB = os.path.join(BASE_PATH, DATA_FOLDER, subdir_2)
    move_outputs(src, dstB, stem=name_stem)

    # load totals (no interpolation within each model)
    vA, fA, compsA = load_total_nointerp(os.path.join(DATA_FOLDER, subdir_1), stem=name_stem)
    vB, fB, compsB = load_total_nointerp(os.path.join(DATA_FOLDER, subdir_2), stem=name_stem)

    # sum across models
    v_sum, f_sum = _sum_models(vA, fA, vB, fB)

    # plot
    fig, ax = plt.subplots(figsize=(7.25,5))

    # plot data (simple groups; same logic as before)
    cmap = plt.get_cmap("tab10")
    filled_markers = ("o","^","<",">","8","s","p","*","h","H","D","d","P","X")
    list_instr=[instrument_data[0]]
    vi=[v_data[0]]; yi=[vFv_data[0]]
    ei_dn=[err_data[0][0]]; ei_up=[err_data[1][0]]
    bi_lo=[nubin_data[0][0]]; bi_hi=[nubin_data[1][0]]
    ui=[uplims[0]]; li=[lolims[0]]
    tmp_c=0; tmp_m=0

    for i in range(1,len(instrument_data)):
        if len(list_instr)-tmp_c >= cmap.N: tmp_c += cmap.N
        if len(list_instr)-tmp_m >= len(filled_markers): tmp_m += len(filled_markers)
        color_index = len(list_instr)-tmp_c
        marker_index = len(list_instr)-tmp_m
        if instrument_data[i] != list_instr[-1]:
            ax.errorbar(vi, yi, xerr=(bi_lo, bi_hi), yerr=(ei_dn, ei_up),
                        uplims=ui, lolims=li, label=str(list_instr[-1]),
                        markersize=4, elinewidth=1, color=cmap(color_index),
                        fmt=filled_markers[marker_index-1])
            list_instr.append(instrument_data[i])
            vi=[v_data[i]]; yi=[vFv_data[i]]
            ei_dn=[err_data[0][i]]; ei_up=[err_data[1][i]]
            bi_lo=[nubin_data[0][i]]; bi_hi=[nubin_data[1][i]]
            ui=[uplims[i]]; li=[lolims[i]]
        else:
            vi.append(v_data[i]); yi.append(vFv_data[i])
            ei_dn.append(err_data[0][i]); ei_up.append(err_data[1][i])
            bi_lo.append(nubin_data[0][i]); bi_hi.append(nubin_data[1][i])
            ui.append(uplims[i]); li.append(lolims[i])

    ax.errorbar(vi, yi, xerr=(bi_lo, bi_hi), yerr=(ei_dn, ei_up),
                uplims=ui, lolims=li, label=str(list_instr[-1]),
                markersize=4, elinewidth=1, color=cmap(0), fmt="o")

    # models and sum
    ax.plot(vA, fA, lw=2, label="Model 1 total")
    ax.plot(vB, fB, lw=2, ls="--", label="Model 2 total")
    ax.plot(v_sum, f_sum, lw=2, ls=":", label="Model 1 + 2")

    ax.set_xscale("log"); ax.set_yscale("log")
    ax.set_xlim(Xlim); ax.set_ylim(Ylim)
    ax.set_xlabel(r"Frequency $\nu$ (Hz)")
    ax.set_ylabel(r"Energy Flux $\nu F_{\nu}$ (erg cm$^{-2}$ s$^{-1})$")
    ax.legend(loc="best", fontsize=9)
    secax = ax.secondary_xaxis('top', functions=(v_to_e, e_to_v))
    secax.set_xlabel("Energy (eV)")
    plt.tight_layout()
    plt.show()
